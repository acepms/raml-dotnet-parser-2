"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var moduleUtils = require("./linkedModuleDetector");
var path = require("path");
var fs = require("fs");
var utils = require("./exportedUtils");
function getModuleGitFolderName(module) {
    var lastSlashPos = module.gitUrl.lastIndexOf("/");
    var gitExtPos = module.gitUrl.lastIndexOf(".git");
    if (gitExtPos == -1)
        gitExtPos = module.gitUrl.length;
    var moduleName = module.gitUrl.substr(lastSlashPos + 1, gitExtPos - lastSlashPos - 1);
    return moduleName;
}
function getExistingModules(folder, modulesToTest) {
    if (!fs.existsSync(folder))
        return {};
    var result = {};
    moduleUtils.subDirectories(folder).forEach(function (subDirectory) {
        var absolutePath = path.join(folder, subDirectory);
        var module = moduleUtils.moduleFromFolder(absolutePath, modulesToTest);
        if (module) {
            module.fsLocation = absolutePath;
            result[module.name] = module;
        }
    });
    return result;
}
function findModulePath(folder, module) {
    if (!fs.existsSync(folder))
        return null;
    var modules = {};
    modules[module.name] = module;
    moduleUtils.subDirectories(folder).forEach(function (subDirectory) {
        var absolutePath = path.join(folder, subDirectory);
        var module = moduleUtils.moduleFromFolder(absolutePath, modules);
        if (module) {
            module.fsLocation = absolutePath;
        }
    });
    return module.fsLocation;
}
function cloneRepositories(rootPath, modules) {
    if (!path.isAbsolute(rootPath)) {
        rootPath = path.resolve(process.cwd(), rootPath);
    }
    var existingModules = getExistingModules(rootPath, modules);
    var result = [];
    Object.keys(modules).forEach(function (moduleName) {
        var module = modules[moduleName];
        var modulePath = path.join(rootPath, getModuleGitFolderName(module));
        if (fs.existsSync(modulePath)) {
            console.log("Module " + moduleName + " already exists at " +
                modulePath + ", skip cloning");
            result.push(modulePath);
            checkoutBranch(modulePath, module);
            return;
        }
        if (existingModules[moduleName]) {
            var realPath = existingModules[moduleName].fsLocation;
            console.log("Module " + moduleName + " already exists at " +
                realPath + ", skip cloning");
            result.push(realPath);
            checkoutBranch(realPath, module);
            return;
        }
        var cloneCommand = null;
        if (module.gitBranch) {
            cloneCommand = "git clone " + module.gitUrl + " --branch " + module.gitBranch + " --single-branch";
        }
        else {
            cloneCommand = "git clone " + module.gitUrl;
        }
        if (utils.execProcess(cloneCommand, rootPath, true) != 0) {
            console.log("Failed to clone repository " + module.gitUrl + " : " + module.gitBranch);
            return;
        }
        var clonedModulePath = findModulePath(rootPath, module);
        if (!clonedModulePath) {
            console.log("Cloned module " + module.name + " does not match its name");
        }
        else {
            result.push(clonedModulePath);
        }
    });
    return result;
}
function checkoutBranch(path, module) {
    if (!module)
        return;
    if (!module.gitBranch)
        return;
    var cloneCommand = "git checkout " + module.gitBranch;
    if (utils.execProcess(cloneCommand, path, true) != 0) {
        console.log("Failed to checkout branch : " + module.gitBranch);
    }
}
function registerNPMModules(repositoryRoots) {
    repositoryRoots.forEach(function (moduleFolder) {
        if (utils.execProcess("npm link", moduleFolder, true) != 0) {
            throw new Error("Could not npm link " + moduleFolder);
        }
    });
}
function npmInstall(repositoryRoots) {
    repositoryRoots.forEach(function (moduleFolder) {
        if (utils.execProcess("npm install", moduleFolder, true) != 0) {
            throw new Error("Could not npm install " + moduleFolder);
        }
    });
}
function installTypings(repositoryRoots, modules) {
    repositoryRoots.forEach(function (moduleFolder) {
        var module = moduleUtils.moduleFromFolder(moduleFolder, modules);
        if (module && module.installTypings) {
            if (utils.execProcess("typings install", moduleFolder, true) != 0) {
                throw new Error("Could not install typings " + moduleFolder);
            }
        }
    });
}
function deleteFolderRecursive(folder) {
    if (fs.existsSync(folder)) {
        if (fs.lstatSync(folder).isSymbolicLink()) {
            fs.unlinkSync(folder);
            return;
        }
        fs.readdirSync(folder).forEach(function (fileName) {
            var childPath = path.join(folder, fileName);
            if (fs.lstatSync(childPath).isDirectory()) {
                deleteFolderRecursive(childPath);
            }
            else {
                fs.unlinkSync(childPath);
            }
        });
        fs.rmdirSync(folder);
    }
}
;
function replaceDependenciesWithLinks(repositoryRoots, modules) {
    repositoryRoots.forEach(function (repositoryRoot) {
        var nodeModulesDir = path.join(repositoryRoot, "node_modules");
        if (!fs.existsSync(nodeModulesDir)) {
            fs.mkdir(nodeModulesDir);
        }
        moduleUtils.subDirectories(nodeModulesDir).forEach(function (subDirectoryName) {
            var subDirectoryAbsolutePath = path.join(nodeModulesDir, subDirectoryName);
            if (fs.realpathSync(subDirectoryAbsolutePath) != subDirectoryAbsolutePath)
                return;
            var module = moduleUtils.moduleFromFolder(subDirectoryAbsolutePath, modules);
            if (!module)
                return;
            deleteFolderRecursive(subDirectoryAbsolutePath);
            if (utils.execProcess("npm link " + module.name, nodeModulesDir, true) != 0) {
                throw new Error("Could not npm link " + module.name + " in " + nodeModulesDir);
            }
        });
    });
}
function replaceDependenciesWithDirectSymlinks(repositoryRoots, modules) {
    var repositoryMap = {};
    for (var _i = 0, repositoryRoots_1 = repositoryRoots; _i < repositoryRoots_1.length; _i++) {
        var repositoryRoot = repositoryRoots_1[_i];
        repositoryMap[path.basename(repositoryRoot)] = repositoryRoot;
    }
    for (var _a = 0, repositoryRoots_2 = repositoryRoots; _a < repositoryRoots_2.length; _a++) {
        var repositoryRoot = repositoryRoots_2[_a];
        var nodeModulesDir = path.join(repositoryRoot, "node_modules");
        if (!fs.existsSync(nodeModulesDir)) {
            fs.mkdirSync(nodeModulesDir);
        }
        var packageJsonPath = path.resolve(repositoryRoot, "package.json");
        if (!fs.existsSync(packageJsonPath)) {
            continue;
        }
        var packageJson = void 0;
        try {
            packageJson = JSON.parse(fs.readFileSync(packageJsonPath, "utf8"));
        }
        catch (e) {
            console.log("Failed to read " + packageJsonPath + ":");
            console.log(e);
            continue;
        }
        var dependencies = packageJson['dependencies'];
        var optDependencies = packageJson['optionalDependencies'];
        if (!dependencies && !optDependencies) {
            continue;
        }
        dependencies = dependencies || {};
        optDependencies = optDependencies || {};
        for (var _b = 0, _c = Object.keys(modules); _b < _c.length; _b++) {
            var moduleName = _c[_b];
            if (!dependencies[moduleName] && !optDependencies[moduleName]) {
                continue;
            }
            var dependencyPath = path.resolve(nodeModulesDir, moduleName);
            var module_1 = modules[moduleName];
            var moduleRepoName = getModuleGitFolderName(module_1);
            var repoPath = repositoryMap[moduleRepoName];
            if (repoPath) {
                deleteFolderRecursive(dependencyPath);
                utils.createSymlink(repoPath, dependencyPath);
            }
        }
    }
}
function setupModules(repositoryRoots, modules, useDirectSymlinks) {
    if (!useDirectSymlinks) {
        registerNPMModules(repositoryRoots);
    }
    npmInstall(repositoryRoots);
    installTypings(repositoryRoots, modules);
    if (useDirectSymlinks) {
        replaceDependenciesWithDirectSymlinks(repositoryRoots, modules);
    }
    else {
        replaceDependenciesWithLinks(repositoryRoots, modules);
    }
}
function setUp(rootFolder, workspaceDescriptorFile, useSymlinks) {
    if (useSymlinks === void 0) { useSymlinks = false; }
    var staticModulesMap = moduleUtils.loadModulesStaticInfo(workspaceDescriptorFile);
    var repositoryRoots = cloneRepositories(rootFolder, staticModulesMap);
    repositoryRoots.forEach(function (repositoryRoot) { return console.log("Reporoot: " + repositoryRoot); });
    setupModules(repositoryRoots, staticModulesMap, useSymlinks);
}
exports.setUp = setUp;
function createSymlinks(rootFolder, workspaceDescriptorFile) {
    var staticModulesMap = moduleUtils.loadModulesStaticInfo(workspaceDescriptorFile);
    var repositoryRoots = cloneRepositories(rootFolder, staticModulesMap);
    repositoryRoots.forEach(function (repositoryRoot) { return console.log("Reporoot: " + repositoryRoot); });
    replaceDependenciesWithDirectSymlinks(repositoryRoots, staticModulesMap);
}
exports.createSymlinks = createSymlinks;
//# sourceMappingURL=devEnvInstaller.js.map